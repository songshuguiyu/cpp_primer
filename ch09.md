9.01 对于下面的程序任务，vector, deque和list哪种容器最为合适？解释你选择的理由。如果没有哪一种容器优于其它容器，也请解释理由。

1.  读取固定数量的单词，将它们按字典序插入到容器中。我们将在下一章看到，关联容器更适合这个问题。
2. 读取未知数量的单词，总是将新单词插入到末尾。删除操作在头部进行。
3. 从一个文件中读取未知数量的整数。将这些整数排序，然后打印到标准输出。

> 1. 使用list，需要在中间插入，用list效率更高。
> 2. 使用deque。只在头尾进行操作，deque效率更高。
> 3. 使用vector。排序需要不断调整位置，vector支持快速随机访问，用vector更适合。

9.02  定义一个list对象，其元素类型是int的deque。

```c++
list<deque<int>>;
```

9.03 构成迭代器范围的迭代器有和限制。

>  begin和end构成了迭代器范围：
>
> 1. 其必须分别指向同一个容器的元素或是尾元素之后的位置。
> 2. 可以通过反复递增begin来到达end。

9.04 编写一个函数，接受一对指向vector<int>的迭代器和一个int值。在两个迭代器指定的范围中查找给定的值，返回一个布尔值来指出是否找到。

```c++
bool findVal(vector<int>::const_iterator beg, vector<int>::const_iterator end, int val)
{
    while (beg != end) {
        if (*beg != val) {
            beg ++;
        }
        else {
            return true;
        }
    }
    return false;
}
```

9.05 重写上一题的函数，返回一个迭代器指向找到的元素。注意，程序必须处理未找到给定值的情况。

```c++
int findVal1(vector<int>::const_iterator beg, vector<int>::const_iterator end, int val)
{
    while (beg != end) {
        if (*beg != val) {
            beg ++;
        }
        else {
            return *beg;
        }
    }
    return *end;
}
```

9.06 下面程序有何错误？你应该如何修改？

```c++
list<int> lstl;
list<int>::iterator iter1 = lstl.begin(),
				   iter2 = lstl.end();
while (iter1 < iter2)	/* ... */
```

> 迭代器之间没有大于小于的比较（比较地址的大小没有必要）。应改为while(iter1 != iter2).

9.07 为了索引int的vector中的元素，应该使用什么类型？

```c++
vector<int>::size_type; // 索引应该是为了便于查找，保存元素的位置。应该是unsigned int类型
```

9.08 为了读取string的list的元素，应该使用什么类型？如果写入list，又该使用什么类型？	

```c++
//读操作
list<string>::const_iterator iter;
//写操作
list<string>::iterator iter;
```

9.09 begin和cbegin两个函数有什么不同？

> begin函数返回的是普通的iterator，而cbegin返回的是const_iterator。

9.10 下面4个对象分别是什么类型？

```c++
vector<int> v1;
const vector<int> v2;
auto it1 = v1.begin(), it2 = v2.begin();
auto it3 = v1.cbegin(), it4 = v2.cbegin();
// it1：iterator类型。it2，it3，it4是const_iterator类型。


```

9.11 对6种创建和初始化vector对象的方法，每一种都给出一个实例。解释每个vector包含什么值。

```c++
vector<int> ivec1;						// 空
vector<int> ivec2{1, 2, 3, 4, 5};		 // 1， 2， 3， 4， 5
vector<int> ivec3 = {6, 7, 8, 9, 10};	  // 6， 7， 8， 9， 10
vector<int> ivec4(ivec2);				 // 1， 2， 3， 4， 5
vector<int> ivec5 = ivec3;				 // 6， 7， 8， 9， 10
vector<int> ivec6(10, 4);				// 10个4
```

9.12 对于接受一个容器创建其拷贝的构造函数，和接受两个迭代器创建拷贝的构造函数，解释它们的不同。

> 1. 接受一个容器创建其拷贝的构造函数，要求两个容器类型及元素类型必须匹配。
> 2. 接受两个迭代器创建拷贝的构造函数，不要求容器类型匹配，而且元素类型也可以不同，只要拷贝的元素能转换就可以。

9.13 如何用一个list<int>初始化一个vector<double>?从一个vector<int>又该如何创建？编写代码验证你的答案。

```c++
list<int> ilist = {1, 2, 3, 4, 5};
vector<double> dvec1(ilist.cbegin(), ilist.cend());
vector<int> ivec = {5, 6, 7, 8};
vector<double> dvec2(ivec.cbegin(), ivec.cend());
```

9.14 编写程序，将一个list中的char*指针（指向C风格字符串）元素赋值给一个vector中的string。

```c++
void test914()
{
    list<char*> pch = {"hello world!", "lucy", "mirror"};
    vector<string> svec;

    svec.assign (pch.cbegin(), pch.cend());

    for (auto i : svec) {
        cout << i << " ";
    }
    cout << endl;
}
```

9.15 编写程序，判定两个vector<int>是否相等。

```c++
void test915()
{
    vector<int> ivec1{1, 2, 3, 4, 5};
    vector<int> ivec2 = {6, 7, 8, 9};
    vector<int> ivec3 = {1, 2, 5};
    vector<int> ivec4 = {1, 2, 3};

    if (ivec1 > ivec2)  cout << "ivec1 > ivec2" << endl;
    else cout << "ivec1 < ivec2" << endl;		
    // ivec1 < ivec2

    if (ivec1 > ivec3) cout << "ivec1 > ivec3" << endl;
    else cout << "ivec1 < ivec3" << endl;
    // ivec1 < ivec3

    if (ivec1 > ivec4) cout << "ivec1 > ivec4" << endl;
    else cout << "ivec1 < ivec4" << endl;
    // ivec1 > ivec4
}
```

9.16 重写上一题的程序，比较一个list<int>中的一个元素和一个vector<int>中的元素。

```c++
void test916()
{
    vector<int> ivec1{1, 2, 3, 4, 5};
    list<int> ilist = {6, 7, 8, 9};

    vector<int> ivec2(ilist.cbegin(), ilist.cend());
    ivec1 < ivec2 ? cout << "ivec1 < ivec2" << endl : cout << "ivec1 > ivec2" << endl;
}
```

9.17 假定c1和c2是两个容器，下面的比较操作有何限制（如果有的话）？

```c++
if (c1 < c2)
```

> 1. 要求c1和c2必须是同类容器，其中元素也必须是同种类型。
> 2. 该容器必须支持比较关系运算。

9.18 编写程序，从标准输入读取string序列，存入一个deque中。编写一个循环，用迭代器打印deque中的元素。

```c++
void test918()
{
    deque<string> sdeq;
    string word;

    while (cin >> word) {
        sdeq.push_back(word);
    }

    for (deque<string>::const_iterator iter = sdeq.cbegin(); iter != sdeq.cend(); iter ++) {
        cout << *iter << "\t";
    }
    cout << endl;
}
```

9.19 重写上题程序，用list代替deque。列出程序要做出哪些改变。

> 1. 将deque改为list类型
> 2. iterator的类型也改为list即可。

9.20 编写程序，从一个list<int>拷贝元素到两个deque中。值为偶数的所有元素都拷贝到一个deque中，而奇数值元素都拷贝到另一个deque中。

```c++
void test920()
{
    list<int> ilist = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    deque<int> even_deq;
    deque<int> odd_deq;

    for (auto i : ilist) {
        if (i % 2) {
            odd_deq.push_back(i);
        }
        else {
            even_deq.push_back(i);
        }
    }
}
```

9.21 如果我们将308页中使用insert返回值将元素添加到list中的循环程序改写为将元素插入到vector中，分析循环将如何工作。

```c++
void test921()
{
    vector<string> svec;
    string word;

    auto beg = svec.begin();
    while (cin >> word) {
        beg = svec.insert(beg, word);
    }
}
// 当输入：hello world lili，输出为：lili world hello
```

9.22 假定iv是一个int的vector，下面的程序存在什么错误？你将如何修改？

```c++
vector<int>::iterator iter = iv.begin(),
					mid = iv.begin() + iv.size()/2;

while(iter != mid) {
    if (*iter == some_val) {
        iv.insert(iter, 2 * some_val);		
    }
}
```

修改为：

```c++
void test922()
{

    vector<int> iv  = {1, 3, 5};
    iv.reserve(5);				// 必须要又足够的容量，否则size为3，插入一个元素之后size超出，iter就会失效，指向未知地址。
    int some_val = 1;

    vector<int>::iterator iter = iv.begin(),
					mid = iv.begin() + iv.size()/2;

    while(iter != mid) {
        if (*iter == some_val) {
            mid = iv.insert(iter, 2 * some_val);	// insert操作要接收返回的迭代器，如果赋给iter，则iter和mid永远不会相等，因为mid也会随之改变。mid接收，mid就和iter都指向首元素了
        }
        else {
            mid --;
        }
    }
```

9.23 在本节第一个程序（309页）中，若c.size()为1， 则val, val2, val3和val4的值会是什么？

> 将会全部指向c容器的首元素。

9.24 编写程序，分别使用at、下标运算符、front和begin提取一个vector中的第一个元素。在一个空vector上测试你的程序。

```c++
void test924()
{
    vector<int> ivec;
    int val1 = ivec[0];         // segment fault
    int val2 = ivec.at(0);          // error, out of range, segment fault
    int val3 = ivec.front();        // segment fault
    int val4 = *ivec.begin();       // segment fault
}
```

9.25 对于312页中删除一个范围内的元素的程序，如果elem1与elem2相等会发生什么？如果elem2是尾后迭代器，或者elem1和elem2皆为尾后迭代器，又会发生什么？

> 如果elem1和elem2相等，则不发生删除操作
>
> 如果elem2是尾后迭代器，则删除elem1之后的元素，返回尾后迭代器。
>
> 如果elem1和elem2都是尾后迭代器，则不发生删除操作。

9.26 使用下面代码定义的ia，将ia拷贝到一个从vector和一个list中。使用单迭代器版本的erase从list中删除奇数元素，从vector中删除偶数元素。

```
void test926()
{
    int ia[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89};
    vector<int> ivec(begin(ia), end(ia));
    list<int> ilist(begin(ia), end(ia));

    vector<int>::iterator iter = ivec.begin();

    while(iter != ivec.end()) {
        if (!(*iter%2)) {
            iter = ivec.erase(iter);
        }else {
            iter ++;
        }
    }

    list<int>::iterator beg = ilist.begin();
    while(beg != ilist.end()) {
        if (*beg%2) {
            beg = ilist.erase(beg);
        }else {
            beg ++;
        }
    }
}
```

9.27 编写程序，查找并删除forward_list<int>中的奇数元素。

```c++
void test927()
{
    int ia[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89};
    forward_list<int> iflst (begin(ia), end(ia));
    auto prev = iflst.before_begin();
    auto curr = iflst.begin();

    while (curr != iflst.end()) {
        if (*curr % 2) {
            curr = iflst.erase_after(prev);
        }
        else {
            prev = curr;
            ++curr;
        }
    }
}
```

9.28 编写函数，接受一个forward_list<string>和两个string共三个参数。函数应在链表中查找第一个string，并将第二个string插入到紧接着第一个string之后的位置。若第一个string未在链表中，则将第二个string插入到链表末尾。

```c++
void insertToFlst(forward_list<string>& sflst, const string& val_in_flst, const string& val_to_insert)
{
    auto prev = sflst.before_begin();
    auto curr = sflst.begin();


    while (curr != sflst.end()) {
        if (*curr == val_in_flst) {
            sflst.insert_after(curr, val_to_insert);
            return;
        }
        else {
            prev = curr;
            ++ curr;
        }
    }
    sflst.insert_after(curr, val_to_insert);
}
```

9.29 假定vec包含25个元素，那么vec.resize(100)会做什么？如果接下来调用vec.resize(10)会做什么？

> vec.resize(100)，会把75个值为0的值添加到vec的结尾。
>
> vec.resize(10)，会把vec末尾的90个元素删除掉。

9.30 接受单个参数的resize版本对元素类型有什么限制（如果有的话）？

> 如果容器保存的是类类型元素，则使用resize必须提供初始值，或元素类型必须提供一个默认构造函数。

9.31 第316页中删除偶数值元素并复制奇数值元素的程序不能用于list或forward_list。为什么？修改程序，使之也能用于这些类型。

```c++
void test931_1()
{
    list<int> ilist = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    auto iter = ilist.begin();
    while (iter != ilist.end()) {
        if (*iter % 2) {
            iter = ilist.insert(iter, *iter);
            advance(iter, 2);       //list和forward_list的迭代器不支持加减操作，因为链表的内存不连续，无法通过加减操作来寻址。
        } else {
            iter = ilist.erase(iter);
        }
    }
}
void test931_2()
{
    forward_list<int> flst = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
    auto iter = flst.begin();
    auto prev = flst.before_begin();
    while (iter != flst.end()) {
        if (*iter % 2) {
            iter = flst.insert_after(prev, *iter);
            advance(prev, 2);
            advance(iter, 2);       
        } else {
            iter = flst.erase_after(prev);
        }
    }
}
```

9.32 再316页的程序中，向下面语句这样调用insert是否合法？如果不合法，为什么？

```c++
iter = vi.insert(iter, *iter++);
```

> 不合法，因为编译器不知道应该先执行insert操作，还是执行*iter++操作。或者执行完insert之后，应该先返回，还是对iter进行++操作。

9.33 在本节最后一个例子中，如果不将insert的结果赋予begin，将会发生什么？编写程序，去掉此赋值语句，验证你的答案。

> 程序崩溃，因为迭代器将会失效。

```c++
vector<int> ivec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    auto iter = ivec.begin();
    while (iter != ivec.end()) {
        ++ iter;
        /* iter = */ivec.insert(iter, 42);
        ++ iter;
    }
```

9.34 假定vi是一个保存int的容器，其中有偶数值也要奇数值，分析下面循环的行为，然后编写程序验证你的分析是否正确。

```c++
iter = vi.begin();
while (iter != vi.end())
    if (*iter % 2)
        iter = vi.insert(iter, *iter);
	++ iter;
```

> 不正确，insert是插入到iter之前，返回的是新插入元素的迭代器，因此在插入元素之后，应该加两次，才能到原始的下一个元素。

```c++
auto iter = ivec.begin();
    while (iter != ivec.end()) {
        if (*iter % 2) {
            iter = ivec.insert(iter, *iter);
            ++ iter;
        }
        ++ iter;
    }
```

9.35 解释一个vector的capacity和size有何区别？

> size是指它已经保存的元素数目，而capacity则是在不分配新的内存空间的前提下最多可以保存的元素。

9.36 一个容器的capacity可能小于它的size吗？

> 不可能，当容量不够，继续添加元素时，容器会自动扩充容量。capacity>=size。

9.37 为什么list或array没有capacity成员函数？

> 因为array时固定长度的。
>
> list不是连续内存，不需要capacity。

9.38 编写程序，探究在你的标准库实现中，vector是如何增长的？

```c++
void test938![微信截图_20180706114407](C:\Users\tutu\Desktop\微信截图_20180706114407.png)()
{
    vector<int> ivec;
    int value;
    while (cin >> value) {
        ivec.push_back(value);
        cout << "the vector's size = " << ivec.size() << endl;
        cout << "the vector's capacity = " << ivec.capacity() << endl;
    }
}
// 运行结果如下图，capacity是双倍增长的，1，2，4，8，16......
```

![微信截图_20180706114407](C:\Users\tutu\Desktop\微信截图_20180706114407.png)

9.39 解释下面程序片段做了什么？

```c++
vector<string> svec;
svec.reserve(1024);
string word;
while (cin >> word) {
    svec.push_back(word);
}
svec.resize(svec.size() + svec.size()/2);
```

> 先给一个vector分配1024大小的空间，将输入的值保存进vector。如果输入的元素大于1024，vector会自动扩容。最后使用resize只能改变vector的size，不能改变其capacity。

9.40 如果上一题的程序读入了256个词，在resize之后容器的capacity可能是多少？如果读入了512个、1000个或1048个词呢？

| elements_num | size | capacity |
| :----------: | :--: | :------: |
|     256      | 384  |   1024   |
|     512      | 768  |   1024   |
|     1000     | 1500 |   2000   |
|     1048     | 1572 |   2096   |

> 当元素数量是1000时，vector自动扩容为元素数量的2倍

9.41 编写程序，从一个vector<char>初始化一个string。

```c++
void test941()
{
    vector<char> cvec = {'a', 'b', 'c', 'd', 'e'};
    string str(cvec.begin(), cvec.end());

    cout << str << endl;
}
```

9.42 假定你希望每次读取一个字符存入一个string中，而且知道最少需要读取100个字符，应该如何提高性能。

> 利用reserve操作预留足够的内存，这样就不用在过程中重新分配内存了。

9.43 编写一个函数，接受三个string参数s，oldVal和newVal.使用迭代器及insert和erase函数将s中所有oldVal替换为newVal。测试你的程序，用它替换通用的简写形式，如，将“tho”替换为“though”，将“thru”替换为“through”。

9.44 重写上一题的函数，这次使用一个下标和replace。

9.45 编写一个函数，接受一个表示名字的string参数和两个分别表示前缀（如“Mr."或”Ms.“）和后缀（Jr或III）的字符串。使用迭代器及insert和append函数将前缀和后缀加到给定的名字中，将生成的新string返回。

9.46 重写上一题的函数，这次使用位置和长度来管理string，并只使用insert。

9.47 编写程序，首先查找string "ab2c3d7R4E6"中的每个数字字符，然后查找其中每个字母字符。编写两个版本的程序，第一个要使用find_fisrt_of，第二个要使用find_first_not_of.

9.48 假定name和numbers的定义如325页所示，number.find(name)返回什么？

9.49 如果一个字母延伸要中线之上，如d或f，则称其有上出头部分。如果延伸到中线之下，则称其有下出头部分。编写程序，读入一个单词文件，输出最长的既不包含上出头部分，也不包含下出头部分的单词。

9.50 编写程序处理一个vector<string>,其元素都表示整形值。计算vector中所有元素之和。修改程序，使之计算表示浮点值的string之和。

9.51 设计一个类，它有三个unsigned成员，分别表示年、月和日。为其编写构造函数，接受一个表示日期的string参数。你的构造函数应该能处理不同数据格式，如January 1，1900、1/1/1990、Jan 1 1900等。

9.52 使用stack处理括号化的表达式。当年看到一个左括号，将其记录下来。当年在一个左括号之后看到一个右括号，从stack中pop对象，直至遇到左括号，将左括号也一起弹出栈。然后将一个值push到栈中，表示一个括号化的表达式已经处理完毕，被其运算结果所替代。